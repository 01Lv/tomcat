# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

applicationContext.addFilter.ise=해당 컨텍스트가 아직 초기화되지 않았기 때문에 필터들은 컨텍스트 [{0}]에 추가될 수 없습니다.
applicationContext.addJspFile.iae=JSP 파일 [{0}]은(는) 유효하지 않습니다.
applicationContext.addListener.iae.cnfe=[{0}] 타입의 인스턴스를 생성할 수 없습니다.
applicationContext.addListener.iae.sclNotAllowed=첫번째 ServletContextListener가 호출되고 나면, 더 이상의 ServletContextListener들은 호출될 수 없습니다.
applicationContext.addListener.iae.wrongType=지정된 타입 [{0}]이(가) 요구되는 리스너 타입들 중의 하나가 아닙니다.
applicationContext.addRole.ise=해당 컨텍스트가 이미 초기화되었기 때문에 역할들이 컨텍스트 [{0}]에 더이상 추가될 수 없습니다.
applicationContext.addServlet.ise=컨텍스트 [{0}]이(가) 이미 초기화되었기 때문에 서블릿들이 추가될 수 없습니다.
applicationContext.invalidFilterName=유효하지 않은 필터 이름 [{0}]으로 인하여 필터 정의를 추가할 수 없습니다.
applicationContext.invalidServletName=유효하지 않은 서블릿 이름 ([{0}]) 때문에 서블릿 정의를 추가하지 못했습니다.
applicationContext.mapping.error=매핑 중 오류 발생
applicationContext.resourcePaths.iae=경로 [{0}]이(가) "/" 문자로 시작하지 않습니다.
applicationContext.roles.iae=컨텍스트 [{0}]을(를) 위해 선언된 역할들의 배열이 널일 수 없습니다.
applicationContext.setAttribute.namenull=속성  이름이 널이어서는 안됩니다.
applicationContext.setSessionTimeout.ise=컨텍스트 [{0}]이(가) 이미 초기화되었기에 세션 타임아웃이 설정될 수 없습니다.
applicationContext.setSessionTracking.iae.invalid=컨텍스트 [{1}]를 위해 요청된 세션 트랙킹 모드 [{0}]은(는) 해당 컨텍스트에서 지원되지 않습니다.
applicationContext.setSessionTracking.ise=컨텍스트 [{0}]을(를) 위한 session tracking mode들은 컨텍스트가 실행되고 있는 중에 설정될 수 없습니다.

applicationDispatcher.serviceException=서블릿 [{0}]을(를) 위한 Servlet.service() 호출 중 익셉션 발생
applicationDispatcher.specViolation.response=원래의 ServletResponse 또는 wrapping된 원래의 ServletResponse 가 RequestDispatcher에 전달되지 않았으며, 이는 SRV.8.2와 SRV.14.2.5.1을 위반합니다.

applicationFilterConfig.jmxUnregister=타입이 [{0}](이)고 이름이 [{1}]인 필터를 위해 JMX 등록 해제가 완료되었습니다.
applicationFilterConfig.preDestroy=타입이 [{1}]이고 이름이 [{0}]인 필터에 대해 preDestroy를 호출하지 못했습니다.

applicationFilterRegistration.nullInitParams=널인 이름 또는 값 때문에, 필터의 초기화 파라미터를 설정할 수 없습니다. 이름: [{0}], 값: [{1}]

applicationServletRegistration.setServletSecurity.iae=[{1}](이)라는 이름의 컨텍스트에 배치된 서블릿 [{0}]을(를) 위해 널 constraint가 지정되었습니다.
applicationServletRegistration.setServletSecurity.ise=해당 컨텍스트가 이미 초기화되었기 때문에, [{1}](이)라는 이름의 컨텍스트에 배치된 서블릿 [{0}]에 security constraint들이 추가될 수 없습니다.

applicationSessionCookieConfig.ise=컨텍스트가 이미 초기화되었기 때문에, 컨텍스트 [{1}]을(를) 위한 SessionCookieConfig에 프로퍼티 [{0}]이(가) 추가될 수 없습니다.

aprListener.config=APR/OpenSSL 설정: useAprConnector [{0}], useOpenSSL [{1}]
aprListener.currentFIPSMode=현재 FIPS 모드: [{0}]
aprListener.enterAlreadyInFIPSMode=AprLifecycleListener가 강제로 FIPS 모드로 들어가도록 설정되었으나, 라이브러리가 이미 FIPS 모드 [{0}]에 들어가 있습니다.
aprListener.initializeFIPSFailed=FIPS 모드로 진입하지 못했습니다.
aprListener.initializedOpenSSL=OpenSSL이 성공적으로 초기화되었습니다: [{0}]
aprListener.initializingFIPS=FIPS 모드를 초기화하고 있습니다.
aprListener.requireNotInFIPSMode=AprLifecycleListener가 이미 FIPS 모드에 있어야만 유효한 라이브러리를 요구하도록 설정되었지만, FIPS 모드에 있지 않은 상태입니다.
aprListener.skipFIPSInitialization=이미 FIPS 모드에 있습니다. FIPS 초기화는 건너뜁니다.
aprListener.sslInit=SSLEngine을 초기화하지 못했습니다.
aprListener.tcnInvalid=APR 기반의 Apache Tomcat Native 라이브러리가 비호환되지 않는 버전 [{0}]이(가) 설치되어 있습니다. Tomcat은 버전 [{1}]을(를) 요구합니다.
aprListener.tcnVersion=APR 기반의 Apache Tomcat Native 라이브러리의 예전 버전 [{0}](이)가 설치되어 있습니다. Tomcat은 최소 버전 [{1}] 설치를 추천합니다.
aprListener.tooLateForFIPSMode=setFIPSMode를 수행할 수 없습니다: SSL이 이미 초기화되었습니다.

asyncContextImpl.dispatchingStarted=비동기 디스패치 오퍼레이션이 이미 호출되었습니다. 동일한 비동기 사이클 내에서 추가적인 비동기 디스패치 오퍼레이션은 허용되지 않습니다.
asyncContextImpl.noAsyncDispatcher=ServletContext로부터 리턴된 dispatcher는 비동기 디스패치를 지원하지 않습니다.
asyncContextImpl.request.ise=complete() 또는 어떠한 종류의 dispatch() 메소드들이 호출된 후에 getRequest()를 호출하는 것은 허용되지 않습니다.
asyncContextImpl.requestEnded=해당 AsyncContext와 연관된 요청은 이미 처리를 완료했습니다.
asyncContextImpl.response.ise=complete() 또는 어떤 종류의 dispatch() 메소드들이 한번 호출된 후에는 getResponse()를 호출할 수 없습니다.

containerBase.backgroundProcess.cluster=클러스터 [{0}]을(를) 백그라운드 프로세스에서 처리하는 동안 오류 발생
containerBase.backgroundProcess.unexpectedThreadDeath=백그라운드 쓰레드 [{0}]이(가) 예기치 않게 종료되었습니다.
containerBase.backgroundProcess.valve=Valve [{0}]의 백그라운드 프로세스를 처리하는 중 익셉션 발생

defaultInstanceManager.invalidInjection=해당 메소드에 잘못된 리소스 Injection annotation이 존재합니다.
defaultInstanceManager.restrictedContainerServlet=클래스 [{0}]을(를) 접근하는 것은 금지되어 있습니다. 해당 클래스는 (ContainerServlet 인터페이스를 구현하고 있는) 접근 제한 클래스입니다. 웹 애플리케이션이 만약 접근하고자 한다면 로드할 수 있는 권한이 설정되어야 합니다.
defaultInstanceManager.restrictedFiltersResource=제한 필터들에 대한 설정 파일을 찾을 수 없습니다: [{0}]
defaultInstanceManager.restrictedListenersResource=RestrictedListeners.properties 파일을 찾을 수 없습니다: [{0}]

filterChain.filter=필터 실행에서 예외가 발생했습니다.
filterChain.servlet=서블릿 실행이 익셉션을 발생시켰습니다.

jreLeakListener.authPolicyFail=javax.security.auth.Policy 클래스에서 메모리 누수를 방지하려 시도하는 중 오류 발생
jreLeakListener.classToInitializeFail=Tomcat을 시작하던 중, 발생 가능성 있는 메모리 누수를 방지하기 위하여, 클래스 [{0}]을(를) 로드하지 못했습니다.
jreLeakListener.gcDaemonFail=Tomcat이 시작하는 동안, 가능한 메모리 누수들을 방지하기 위한 GC Daemon을 생성하려 개시한 것이 실패했습니다. 이는 Sun JVM들이 아닌 환경에서는 발생할 수 있습니다.
jreLeakListener.jarUrlConnCacheFail=Jar URL 연결 캐싱을 사용불능 상태를 기본 값으로 설정하지 못했습니다.
jreLeakListener.xmlParseFail=XML 파싱 중 메모리 누수를 방지하려 시도하는 중 오류 발생

naming.addEnvEntry=Environment entry [{0}]을(를) 추가합니다.
naming.invalidEnvEntryValue=Environment 엔트리 [{0}]이(가) 유효하지 않은 값을 가지고 있습니다.
naming.jmxRegistrationFailed=JMX 내에서 등록 실패했습니다: [{0}]
naming.namingContextCreationFailed=naming context 생성이 실패했습니다: [{0}]
naming.wsdlFailed=wsdl 파일을 찾을 수 없습니다: [{0}]

noPluggabilityServletContext.notAllowed=Servlet 3.0 스펙 Section 4.4는 이 메소드가, web.xml, a web-fragment.xml file 또는 @WebListener로 annotate되지 않은 ServletContextListener로부터 호출되는 것을 허용하지 않습니다.

standardContext.applicationListener=클래스가 [{0}]인 애플리케이션 리스너를 설정하는 중 오류 발생
standardContext.applicationSkipped=이전 오류(들)로 인하여 애플리케이션 리스너들을 설치하는 것을 건너뜁니다.
standardContext.backgroundProcess.instanceManager=인스턴스 매니저 [{0}]을(를) 백그라운드 프로세스에서 처리 중 익셉션 발생
standardContext.backgroundProcess.loader=로더 [{0}]을(를) 백그라운드 프로세스에서 수행 중 익셉션 발생
standardContext.backgroundProcess.manager=매니저 [{0}]을(를) 백그라운드 프로세스로 처리하는 도중 익셉션 발생
standardContext.cluster.noManager=매니저가 발견되지 않습니다. 클러스터 매니저가 사용되어야 하는지 검사합니다. 설정된 클러스터: [{0}], 배포할 수 있는 애플리케이션: [{1}]
standardContext.duplicateListener=리스너 [{0}]은(는) 이미 이 컨텍스트를 위해 설정되어 있습니다. 중복된 정의는 무시되었습니다.
standardContext.errorPage.error=오류 페이지 위치 [{0}]은(는) 반드시 ''/''로 시작해야 합니다.
standardContext.errorPage.required=ErrorPage는 널이어서는 안됩니다.
standardContext.extensionValidationError=필수적으로 요구되는 애플리케이션 extension들을 validate하려 시도 중 오류 발생
standardContext.filterFail=하나 이상의 필터들이 시작을 하지 못했습니다. 상세 내역은 해당 컨테이너 로그 파일에서 찾을 수 있습니다.
standardContext.filterMap.name=필터 매핑이 알려지지 않은 필터 이름 [{0}]으로 설정되었습니다.
standardContext.filterMap.pattern=필터 매핑에서 유효하지 않은 <url-pattern>: [{0}]
standardContext.filterStart=필터 [{0}]을(를) 시작하는 중 오류 발생
standardContext.invalidWrapperClass=[{0}]은(는) StandardWrapper의 자식 클래스가 아닙니다.
standardContext.isUnavailable=이 애플리케이션은 현재 가용 상태가 아닙니다.
standardContext.listenerFail=하나 이상의 리스너(들)이 시작하지 못했습니다. 상세 내역은 적절한 컨테이너 로그 파일에서 찾을 수 있습니다.
standardContext.listenerStart=Context initialized event를 [{0}] 클래스의 인스턴스인 리스너에 전송하는 동안 익셉션이 발생하였습니다.
standardContext.listenerStop=contextDestroyed 이벤트를 클래스 [{0}]의 인스턴스인 리스너에게 전송하는 중 익셉션 발생
standardContext.loginConfig.errorPage=폼 에러 페이지 [{0}]은(는) 반드시 "/"로 시작해야 합니다.
standardContext.loginConfig.errorWarning=주의: Servlet 2.4에서 폼 에러 페이지 [{0}]은(는) 반드시 "/" 로 시작하여야 합니다.
standardContext.loginConfig.loginPage=폼 로그인 페이지 [{0}]은(는) 반드시 ''/''로 시작해야 합니다.
standardContext.loginConfig.loginWarning=경고: Servlet 2.4에서 폼 로그인 페이지 [{0}]은(는) 반드시 ''/''로 시작해야 합니다.
standardContext.manager=[{0}] 클래스의 매니저를 설정했습니다.
standardContext.managerFail=세션 매니저가 시작하지 못했습니다.
standardContext.noResourceJar=리소스 JAR들은 지원되지 않습니다. [{0}]에 위치한 JAR는 이름이 [{1}]인 컨텍스트를 위한 정적 컨텐트를 제공하는 데에 사용되지 않을 것입니다.
standardContext.notStarted=[{0}](이)라는 이름을 가진 컨텍스트는 아직 시작되지 않았습니다.
standardContext.parameter.duplicate=중복된 context 초기화 파라미터: [{0}]
standardContext.postconstruct.duplicate=클래스 [{0}]에서 중복된 post construct 메소드 정의가 발견됨
standardContext.predestroy.required=Fully qualified 클래스 이름과 메소드 이름 둘 모두 필수적으로 요구됩니다.
standardContext.requestListener.requestInit=클래스 [{0}]의 리스너에게 request initialized 생명주기 이벤트를 전송하는 중 익셉션 발생
standardContext.resourcesInit=정적 리소스들을 초기화하는 중 오류 발생
standardContext.resourcesStop=정적 리소스들을 중지시키는 중 오류 발생
standardContext.securityConstraint.mixHttpMethod=<http-method> 와 <http-method-omission> 을 동일한 web resource collection에 포함하는 것은 허용되지 않습니다.
standardContext.securityConstraint.pattern=security constraint 엘리먼트에서 유효하지 않은 <url-pattern> [{0}]입니다.
standardContext.servletMap.name=서블릿 매핑이 알려지지 않은 서블릿 이름 [{0}]을(를) 지정했습니다.
standardContext.startFailed=이전 오류으로 인해 컨텍스트 [{0}] 시작에 실패했습니다.
standardContext.startingContext=이름이 [{0}]인 컨텍스트를 시작하는 중 익셉션 발생
standardContext.threadBindingListenerError=컨텍스트 [{0}]을(를) 위해 설정된 쓰레드 바인딩 리스너에서 오류가 발생했습니다.
standardContext.unknownCookieEncoding=알려지지 않은 인코딩 [{0}]은(는) setCookieEncoding(String)을 위해 설정되었으므로 기본 인코딩인 UTF-8이 대신 사용될 것입니다.
standardContext.urlPattern.patternWarning=경고: Servlet 2.4에서 URL 패턴 [{0}]은(는) 반드시 ''/''로 시작해야 합니다.
standardContext.workCreateException=컨텍스트 [{2}]을(를) 위한 디렉토리 [{0}]와(과) CATALINA_HOME [{1}](으)로부터 work 디렉토리의 절대 경로를 결정할 수 없습니다.
standardContext.workCreateFail=컨텍스트 [{1}]을(를) 위한 work 디렉토리 [{0}]을(를) 생성할 수 없습니다.
standardContext.workPath=컨텍스트 [{0}]을(를) 위한 work 경로를 구하는 중 익셉션 발생

standardEngine.jvmRouteFail=엔진의 jvmRoute 속성을 시스템 프로퍼티로부터 설정하는 데에 실패했습니다.
standardEngine.notHost=엔진의 자식은 반드시 호스트여야 합니다.
standardEngine.notParent=엔진은 부모 컨테이너를 가질 수 없습니다.

standardHost.clientAbort=원격 클라이언트가 요청을 중단시켰습니다, IOException: [{0}]
standardHost.nullName=호스트 이름이 필수적으로 설정되어야 합니다.

standardServer.portOffset.invalid=portOffset이 음수여서는 안되기 때문에, portOffset의 값 [{0}]은(는) 유효하지 않습니다.
standardServer.shutdownViaPort=셧다운 포트를 통해 유효한 셧다운 커맨들를 받았습니다. 서버 인스턴스를 중지시킵니다.
standardServer.storeConfig.notAvailable=[{0}](이)라는 이름을 가진 MBean으로서 어떤 StoreConfig 구현 객체도 등록되지 않았습니다.  통상 StoreConfigLifecycleListener을 통하여 적절한 MBean이 등록됩니다.

standardService.engine.startFailed=연관된 엔진을 시작하지 못했습니다.
standardService.mapperListener.startFailed=연관된 MapperListener를 시작하지 못했습니다.
standardService.start.name=시작 서비스 [{0}]
standardService.stop.name=서비스 [{0}]을(를) 중지시킵니다.

standardWrapper.allocate=서블릿 인스턴스를 할당하는 중 오류 발생
standardWrapper.allocateException=서블릿 [{0}]을(를) 위해 익셉션을 할당합니다.
standardWrapper.instantiate=서블릿 클래스 [{0}](으)로부터 인스턴스 생성하는 중 오류 발생
standardWrapper.isUnavailable=서블릿 [{0}]은(는) 현재 사용할 수 없습니다.
standardWrapper.notChild=Wrapper 컨테이너는 자식 컨테이너들을 가질 수 없습니다.
standardWrapper.notClass=서블릿 [{0}]을(를) 위해 서블릿 클래스가 지정되지 않았습니다.
standardWrapper.notContext=Wrapper의 부모 컨테이너는 반드시 컨텍스트이어야 합니다.
standardWrapper.notFound=서블릿 [{0}]은(는) 가용하지 않습니다.
standardWrapper.releaseFilters=서블릿 [{0}]을(를) 위해 필터를 release하던 중 익셉션 발생
standardWrapper.serviceException=경로가 [{1}]인 컨텍스트의 서블릿 [{0}]을(를) 위한 Servlet.service() 호출이 익셉션을 발생시켰습니다.
standardWrapper.unloading=서블릿이 Unload 되었기 때문에, 서블릿 [{0}]을(를) 할당할 수 없습니다.
standardWrapper.waiting=서블릿 [{1}]을(를) 위해 [{0}]개의 인스턴스(들)이 할당해제되기를 기다립니다.
