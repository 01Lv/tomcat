# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

webappClassLoader.addExportsThreadLocal=Java 9 환경에서 실행할 때에는 "--add-opens=java.base/java.lang=ALL-UNNAMED"를 JVM 커맨드 라인 아규먼트들로 추가하여 ThreadLocal 메모리 누수 탐지를 활성화시켜야 합니다. 혹은, ThreadLocal 메모리 누수 탐지를 비활성화시켜 이 경고 메시지가 나오지 않도록 할 수 있습니다.
webappClassLoader.addTransformer.duplicate=웹 애플리케이션 [{1}]에 클래스 파일 변환기 [{0}]을(를) 추가하기 위한 중복된 호출을 무시합니다.
webappClassLoader.addTransformer.illegalArgument=웹 애플리케이션 [{0}]이(가) 널 클래스 파일 Transformer을 추가하려 시도했습니다.
webappClassLoader.checkThreadLocalsForLeaks=웹 애플리케이션 [{0}]이(가) 타입이 [{1}]이고 (값: [{2}]) 값의 타입이 [{3}]인 키로서 (값: [{4}]) ThreadLocal을 생성했습니다만, 웹 애플리케이션이 중지될 때 그것을 제거하지 못했습니다. 혹시 있을 법한 메모리 누수를 방지하기 위하여, 시간을 두고 쓰레드들을 재생성할 것입니다.
webappClassLoader.checkThreadLocalsForLeaks.unknown=알 수 없음.
webappClassLoader.checkThreadLocalsForLeaksFail=웹 애플리케이션 [{0}]을(를) 위해 ThreadLocal 참조들에 대한 검사에 실패했습니다.
webappClassLoader.checkThreadLocalsForLeaksNull=웹 애플리케이션 [{0}]이(가) 타입이 [{1}]인 키로서 (값: [{2}]) ThreadLocal을 생성했습니다. 해당 ThreadLocal은 올바르게 널로 설정되었고 해당 키는 GC에 의해 제거되었습니다..
webappClassLoader.checkThreadsHttpClient=웹 애플리케이션 클래스로더를 사용한 HttpClient keep-alive 쓰레드를 발견했습니다. 쓰레드의 클래스로더를 부모 클래스로더로 전환시켰습니다.
webappClassLoader.clearReferencesResourceBundlesCount=ResourceBundle [{0}]에 대한 참조들을 [{1}] 웹 애플리케이션을 위한 캐시로부터 제거하였습니다.
webappClassLoader.getThreadGroupError=ThreadGroup [{0}]의 부모 ThreadGroup을 얻을 수 없습니다. 잠재적인 메모리 누수 문제에 대하여 모든 쓰레드들을 검사하는 것은 불가능합니다.
webappClassLoader.illegalJarPath=[{0}](이)라는 이름을 가진 불허되는 JAR 엔트리가 탐지되었습니다.
webappClassLoader.jarsAdded=하나 이상의 JAR들이 웹 애플리케이션 [{0}]에 추가됐습니다.
webappClassLoader.jarsModified=웹 애플리케이션 [{0}]의 하나 이상의 JAR 파일(들)이 변경되었습니다.
webappClassLoader.jarsRemoved=하나 이상의 JAR들이 웹 애플리케이션 [{0}](으)로부터 제거되었습니다.
webappClassLoader.readError=리소스 읽기 오류 : [{0}]을(를) 로드할 수 없습니다.
webappClassLoader.stackTrace=해당 웹 애플리케이션 [{0}]은(는) [{1}](이)라는 이름이 붙여진 쓰레드를 시작시킨 것으로 보입니다만 그 쓰레드를 중지시키지 못했습니다. 이는 메모리 누수를 유발할 수 있습니다. 해당 쓰레드의 스택 트레이스:{2}
webappClassLoader.stopThreadFail=웹 애플리케이션 [{1}]을 위한, [{0}](이)라는 이름의 쓰레드를 종료시키지 못했습니다.
webappClassLoader.stopTimerThreadFail=웹 애플리케이션[{1}] 에 대해 TimerThread[{0}]를 종료하는데 실패 하였습니다.
webappClassLoader.stopped=불허되는 접근: 이 웹 애플리케이션 인스턴스는 이미 중지되었습니다. [{0}]을(를) 로드할 수 없습니다. 디버그 목적과 불허되는 접근을 유도한 해당 쓰레드를 종료시키기 위한 시도로서 다음 스택 트레이스가 생성되었습니다.
webappClassLoader.superCloseFail=슈퍼 클래스의 close() 메소드 호출 실패
webappClassLoader.transformError=Instrumentation 오류: 해당 클래스 [{0}]이(가) 정상적으로 유효한 클래스 파일 포맷이 아니기 때문에 변환시킬 수 없습니다.
webappClassLoader.validationErrorJarPath=[{0}](이)라는 이름을 가진 엔트리를 JAR 파일 내에서 찾을 수 없습니다.
webappClassLoader.warnTimerThread=웹 애플리케이션 [{0}]은(는) java.util.Timer API를 통해 [{1}](이)라는 이름을 가진 TimerThread를 시작한 것으로 보입니다만 그 쓰레드를 중지시키지 못했습니다. 메모리 누수를 방지하기 위하여, 타이머(그리고 그와 연관된 쓰레드)가 강제로 취소되었습니다.
webappClassLoader.wrongVersion=(클래스 [{0}]을(를) 로드할 수 없습니다)

webappLoader.classDeploy=클래스 파일들 [{0}]을(를) [{1}](으)로 배치합니다.
webappLoader.deploy=work 디렉토리 [{0}]에 클래스 레파지토리들을 배치합니다.
webappLoader.readFailure=리소스 [{0}]을(를) 읽을 수 없습니다.
webappLoader.setContext.ise=해당 웹 애플리케이션 로더가 시작되고 있는 동안 컨텍스트를 설정 변경하는 것은 허용되지 않습니다.
