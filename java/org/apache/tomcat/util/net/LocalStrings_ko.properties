# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

channel.nio.interrupted=현재 쓰레드는 중단되었습니다.
channel.nio.ssl.appInputNotEmpty=애플리케이션 입력 버퍼가 아직 데이터를 가지고 있습니다. 데이터를 잃을 수도 있었습니다.
channel.nio.ssl.appOutputNotEmpty=애플리케이션 출력 버퍼가 아직 데이터를 가지고 있습니다. 데이터를 잃을 수도 있었습니다.
channel.nio.ssl.eofDuringHandshake=handshake 하는 동안 EOF
channel.nio.ssl.expandNetInBuffer=네트워크 입력 버퍼를 [{0}] 바이트 만큼 확장합니다.
channel.nio.ssl.expandNetOutBuffer=네트워크 출력 버퍼를 [{0}] 바이트 크기로 확장합니다.
channel.nio.ssl.handshakeError=Handshake 오류
channel.nio.ssl.invalidCloseState=유효하지 않은, 닫힘 상태입니다. 네트워크로 데이터를 전송하지 않을 것입니다.
channel.nio.ssl.netInputNotEmpty=네트워크 입력 버퍼가 여전히 데이터를 포함하고 있습니다. Handshake가 실패할 것입니다.
channel.nio.ssl.notHandshaking=Handshake 중 NOT_HANDSHAKING 발생
channel.nio.ssl.remainingDataDuringClose=네트워크 버퍼에 데이터가 남아있습니다. SSL close 메시지를 보낼 수 없습니다. close(true)를 대신 사용해 강제로 닫으려 합니다.
channel.nio.ssl.sniDefault=요청된 SNI 호스트 이름을 결정하기 위한 충분한 버퍼를 생성할 수 없습니다. 기본 값을 사용합니다.
channel.nio.ssl.sniHostName=연결 [{0}](으)로부터 추출된 SNI 호스트 이름은 [{1}]입니다.
channel.nio.ssl.unexpectedStatusDuringUnwrap=Handshake UNWRAP 처리 중 예기치 않은 상태: [{0}]
channel.nio.ssl.unexpectedStatusDuringWrap=WRAP을 위해 handshake하는 동안 예기치 않은 상태 [{0}]입니다.
channel.nio.ssl.unwrapFail=데이터를 unwrap할 수 없습니다. 유효하지 않은 결과 상태값입니다: [{0}]

endpoint.accept.fail=소켓 accept 실패
endpoint.alpn.fail=[{0}]을(를) 사용하여 ALPN을 위한 엔드포인트를 설정하지 못했습니다.
endpoint.alpn.negotiated=ALPN을 사용하여 negotiated 프로토콜 [{0}]을(를) 설정함.
endpoint.apr.applyConf=OpenSSLConfCmd를 SSL context에 적용합니다.
endpoint.apr.assignConf=SSL context를 OpenSSLConfCmd context로 설정합니다.
endpoint.apr.checkConf=OpenSSLConf 검사를 수행합니다.
endpoint.apr.errCheckConf=OpenSSLConf 검사 중 오류 발생
endpoint.apr.errMakeConf=OpenSSLConf context를 생성하지 못했습니다.
endpoint.apr.failSslContextMake=SSLContext를 생성할 수 없습니다. AprLifecycleListener에서 SSLEngine이 사용가능 상태로 설정되었는지, AprLifecycleListener가 올바로 초기화되었는지, 그리고 유효한 SSLProtocol이 지정되었는지 검사하십시오.
endpoint.apr.invalidSslProtocol=SSLProtocol 속성을 위해 제공된 값, [{0}], 은 유효하지 않습니다.
endpoint.apr.maxConnections.running=해당 APR 엔드포인트는 실행 중 maxConnections 설정을 지원하지 않습니다. 기존 값인 [{0}]이(가) 계속해서 사용될 것입니다.
endpoint.apr.maxConnections.unlimited=해당 APR 엔드포인트는 무제한 연결들을 지원하지 않습니다. 기존 값인 [{0}]이(가) 계속해서 사용될 것입니다.
endpoint.apr.noSslCertFile=Connector의 속성인 SSLCertificateFile은 반드시 SSL을 APR과 함께 사용할 때에만 정의되어야 합니다.
endpoint.apr.pollAddInvalid=소켓 [{0}]을(를) 해당 Poller에 추가를 시도하기에는 유효하지 않는 조건입니다.
endpoint.apr.pollError=Poller가 다음 오류와 함께 실패했습니다. [{0}] : [{1}]
endpoint.apr.tooManyCertFiles=AprEndpoint가 처리할 수 있는 양 보다 더 많은 인증서 파일들이 설정되었습니다.
endpoint.debug.channelCloseFail=채널을 닫는데 실패했습니다.
endpoint.debug.pollerAdd=addList에 추가합니다: 소켓 [{0}], 타임아웃 [{1}], 플래그들 [{2}]
endpoint.debug.pollerAddDo=Poller에 소켓 [{0}]을(를) 추가합니다.
endpoint.debug.pollerProcess=다음 이벤트(들)을 위해 소켓 [{0}]을(를) 처리합니다: [{1}]
endpoint.debug.pollerRemove=Poller에서 [{0}]을(를) 제거하려 시도 중
endpoint.debug.socket=소켓 [{0}]
endpoint.debug.socketCloseFail=소켓을 닫는 데에 실패함.
endpoint.debug.socketTimeout=작업시간 초과 검사: [{0}]
endpoint.debug.unlock.localFail=[{0}]을(를) 위한 로컬 주소를 결정할 수 없습니다.
endpoint.duplicateSslHostName=호스트 이름 [{0}]을(를) 위해 여러 개의 SSLHostConfig 엘리먼트들이 제공되었습니다. 호스트 이름들은 유일해야 합니다.
endpoint.getAttribute=[{0}]은(는) [{1}]
endpoint.init.bind=소켓 바인딩 실패: [{0}] [{1}]
endpoint.init.notavail=APR이 가용하지 않습니다.
endpoint.invalidJmxNameSslHostCert=호스트가 [{0}] 이고 인증서 타입이 [{1}]인 SSLHostConfigCertificate을 위한 유효한 JMX 객체 이름을 생성할 수 없습니다.
endpoint.jmxRegistrationFailed=[{0}](이)라는 이름을 가진 JMX 객체를 등록시키지 못했습니다.
endpoint.jsse.noSslContext=호스트 이름 [{0}]을(를) 위한 SSLContext를 찾을 수 없습니다.
endpoint.launch.fail=새로운 runnable을 시작하지 못했습니다.
endpoint.nio.registerFail=Poller로부터의 selector와 함께 소켓을 등록하지 못했습니다.
endpoint.nio.stopLatchAwaitFail=Poller들이 요구되는 시간 내에 중지되지 않았습니다.
endpoint.nio.stopLatchAwaitInterrupted=이 쓰레드는 poller들이 중지되기를 기다리는 동안 중단되었습니다.
endpoint.nio2.exclusiveExecutor=NIO2 connector가 셧다운 시에 정상적으로 동작하기 위해서는 배타적인 executor를 필요로 합니다.
endpoint.noSslHostConfig=호스트 이름 [{0}]가 커넥터 [{1}]의 defaultSSLHostConfigName과 일치하는SSLHostConfig 요소를 찾을 수 없습니다.
endpoint.noSslHostName=해당 SSL 호스트 설정을 위해 어떤 호스트 이름도 제공되지 않았습니다.
endpoint.poll.fail=심각한 poller 실패 (poller를 재시작합니다): [{0}] [{1}]
endpoint.poll.initfail=Poller 생성을 실패했습니다.
endpoint.poll.limitedpollsize=지정된 크기 [{0}]로 poller를 생성하지 못했습니다.
endpoint.pollerThreadStop=Poller 쓰레드가 적절한 시간 내에 중지되지 못했습니다.
endpoint.portOffset.invalid=portOffset 값은 음수일 수 없기 때문에 portOffset을 값 [{0}]은(는) 유효하지 않습니다.
endpoint.processing.fail=소켓 프로세서 실행 중 오류 발생
endpoint.sendfile.addfail=Sendfile 실패: [{0}] [{1}]
endpoint.sendfile.error=예기치 않은 sendfile 오류
endpoint.sendfileThreadStop=해당 sendfile 쓰레드가 정해진 시간 내에 종료되지 못했습니다.
endpoint.serverSocket.closeFailed=엔드포인트 [{0}]을(를) 위한 서버 소켓을 닫지 못하였습니다.
endpoint.setAttribute=[{1}]에 [{0}]을(를) 할당합니다.
endpoint.warn.executorShutdown=쓰레드 풀 [{0}]와(과) 연관된 해당 Executor는 완전히 종료되지 않았습니다. 일부 애플리케이션 쓰레드들이 아직 동작 중일 수 있습니다.
endpoint.warn.incorrectConnectionCount=부정확한 연결 개수. 동일한 소켓에 여러번의 socket.close가 호출되었음.
endpoint.warn.noLocalName=소켓 [{0}]을 위한 로컬 호스트 이름을 결정할 수 없습니다.
endpoint.warn.noLocalPort=소켓 [{0}]의 로컬 포트 번호를 결정할 수 없습니다.
endpoint.warn.noSendfileWithSSL=SSL이 사용가능 상태일 때에는 sendfile이 해당 connector에서 지원되지 않습니다.
endpoint.warn.unlockAcceptorFailed=Acceptor 쓰레드 [{0}]이(가) 잠금해제를 하지 못했습니다. 강제로 소켓을 셧다운합니다.

jsse.ssl3=SSLv3이 명시적으로 사용 가능 상태로 설정되었습니다. 이 프로토콜은 안전하지 않은 것으로 알려져 있습니다.

sniExtractor.clientHelloInvalid=ClientHello 메시지가 정확히 포맷되지 않았습니다.
sniExtractor.clientHelloTooBig=ClientHello가 단일 TLS 레코드에 존재하지 않기에 SNI 정보를 추출할 수 없습니다.

socket.apr.clientAbort=클라이언트가 연결을 중단했습니다.
socket.apr.closed=이 연결과 연관된 소켓 [{0}]이(가) 이미 닫혀 있습니다.
socket.closed=이 연결과 연관된 해당 소켓은 이미 닫혔습니다.

sslHostConfig.certificate.notype=복수의 인증서들이 설정되었으며, 적어도 하나 이상의 인증서는 필수 속성 타입이 존재하지 않습니다.
sslHostConfig.certificateVerificationInvalid=인증서 검증 값 [{0}]은(는) 인식되지 않습니다.
sslHostConfig.fileNotFound=설정된 파일 [{0}]이 존재 하지 않습니다.
sslHostConfig.mismatch=[{1}](이)라는 이름의 SSLHostConfig에 프로퍼티 [{0}]이(가) 설정되었는데, 이 프로퍼티는 [{2}] 설정 문법을 위한 것이나 해당 SSLHostConfig은 [{3}] 설정 문법으로 사용되고 있습니다.
sslHostConfig.opensslconf.alreadyset=OpenSSLConf이 이미 설정되어 있기 때문에 또 다른 것을 설정하려는 시도는 무시됩니다.
sslHostConfig.opensslconf.null=널인 OpenSSLConf를 설정하려는 시도가 무시되었습니다.
sslHostConfig.prefix_missing=프로토콜 [{0}]이(가) [{1}](이)라는 이름을 가진 SSLHostConfig의 프로토콜 목록에 추가되었습니다. +/- prefix가 결여되었는지 검사하십시오.

sslHostConfigCertificate.mismatch=프로퍼티 [{0}]이(가)  [{1}](이)라는 이름의 SSLHostConfigCertificate에 설정되었으나, 이는 인증서 저장소 타입 [{2}]을(를) 위한 것이지만 해당 인증서는 저장소 타입 [{3}]와(과) 함께 사용되고 있습니다.

sslImplementation.cnfe=[{0}] 클래스의 SSLImplementation을 생성할 수 없습니다.

sslUtilBase.active=활성화 된 [{0}]은(는) 다음과 같습니다: [{1}]
sslUtilBase.noneSupported=지정된 [{0}]의 어느 것도 SSL 엔진에 의해 지원되지 않습니다: [{1}]
sslUtilBase.skipped=지정된 [{0}]의 일부는 SSL 엔진에 의해 지원되지 않아 건너뜁니다: [{1}]
